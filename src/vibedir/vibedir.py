import argparse
import os
import logging
import yaml
from typing import Dict, Optional

def load_config(config_path: str) -> Dict:
    """Load vibedir configuration from YAML file."""
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except Exception as e:
        logging.error(f"Failed to load config from {config_path}: {e}")
        return {}

def build_prompt(prepped_dir_path: str, user_request: str, config: Dict) -> str:
    """Construct a prompt for Grok 3 based on prepped_dir.txt and user request."""
    try:
        with open(prepped_dir_path, 'r', encoding='utf-8') as f:
            prepped_dir_content = f.read()
    except Exception as e:
        logging.error(f"Failed to read {prepped_dir_path}: {e}")
        raise

    prompt_template = config.get("prompt_template", """
You are a code modification assistant. Below is the content of a prepped_dir.txt file generated by prepdir, listing files and additional commands for a project. Your task is to apply the following changes: {user_request}. Return the modified content in a file named modified_prepped_dir.txt, preserving the original format, including delimiters (e.g., =-=, ===---===), file markers (Begin File, End File), and additional commands section. Ensure filenames in Begin File and End File markers match exactly, and only include valid code changes.

=== prepped_dir.txt Content ===
{prepped_dir_content}
=== End prepped_dir.txt Content ===

Output the modified content as modified_prepped_dir.txt with the same structure.
""")
    return prompt_template.format(
        user_request=user_request,
        prepped_dir_content=prepped_dir_content
    )

def call_grok_api(prompt: str, config: Dict) -> str:
    """Send prompt to Grok 3 API and return modified_prepped_dir.txt content."""
    # Placeholder for API integration
    # Example: Use xAI's API client (configured via config["api_key"])
    logging.info("Calling Grok 3 API (placeholder)")
    return "Mock modified_prepped_dir.txt content"

def save_output(content: str, output_path: str) -> None:
    """Save Grok 3's output to the specified file."""
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)
        logging.info(f"Saved output to {output_path}")
    except Exception as e:
        logging.error(f"Failed to save output to {output_path}: {e}")
        raise

def main():
    parser = argparse.ArgumentParser(description="Interact with Grok 3 to modify prepped_dir.txt.")
    parser.add_argument("prepped_dir", help="Path to prepped_dir.txt from prepdir")
    parser.add_argument("--output", default="modified_prepped_dir.txt", help="Output file for modified content")
    parser.add_argument("--request", required=True, help="Change request for Grok 3 (e.g., 'Refactor test_file.py')")
    parser.add_argument("--manual", action="store_true", help="Output prompt for manual editing instead of API call")
    parser.add_argument("--config", default="vibedir.yaml", help="Path to configuration file")
    args = parser.parse_args()

    # Load configuration
    config = load_config(args.config)
    logging.basicConfig(level=config.get("logging", {}).get("level", "INFO"))

    # Build prompt
    prompt = build_prompt(args.prepped_dir, args.request, config)

    if args.manual:
        print("=== Prompt for Grok 3 ===")
        print(prompt)
        print("=== End Prompt ===")
        print(f"Please save Grok 3's output as {args.output}")
    else:
        # Call Grok 3 API
        modified_content = call_grok_api(prompt, config)
        # Save output
        save_output(modified_content, args.output)

if __name__ == "__main__":
    main()