# config.toml
# Note this file holds user default settings. If config changes are made during a session,
# those are automatically reloaded on the next session. To prevent this load,
# remove or rename .vibedir/config.json

# The mode determines how vibedir is used:
# clipboard: prompts are shared with an LLM via copy/paste
# api: interactions with an LLM are handled via API. 
# Note LLM tag must be defined to use API mode.
mode = "clipboard"  # [clipboard|api] if api then llm tag must be defined

[llm]
# If using API mode, the following LLM information must be defined
# (this will be fleshed out as apibump is developed)
# The plan is to require an LLM key and an apibump key to be defined in .netrc/other
model = "grok-4"
endpoint = "https://api.x.ai/v1"

# If using CLIPBOARD mode, set the max number of characters per file
# (to work around LLM UI file truncation)
clipboard_max_chars_per_file = 40000

# ===================================================================
# Source Control (e.g. git) & COMMITS
# ===================================================================
# The LLM can be asked to provide a commit message for each set of changes.
# If ask_llm_for_commit_message is set to false, then we will not ask for commit
# messages from the LLM (token savings) but the user will need to generate an
# appropriate commit message for each set of changes.
ask_llm_for_commit_message = true  # [true|false]
show_working_commit_message = true  # [true|false] show the working commit message in the header
show_previous_commit_message = true  # [true|false] show the previous commit message in the header

# If auto commit is set to:
#   previous: a commit will be automatically performed for the previous code changes
#              on a prompt copy call or before new code changes are made
#   latest: a commit will be automatically performed after each successful set of
#           code changes from the LLM (via applydir)
#   off: do not automatically perform commits
auto_commit = "previous"  # [previous|latest|off]
commit_command = "git commit -a -m \"{{ commit_message }}\""  # commit_message will be filled with the working commit message
revert_changes_command = "git checkout -- . && git reset"
last_commit_message_command = "git log -1 --pretty=%B"
changes_exist_command = "git diff --quiet HEAD"
changes_exist_result = "exit_code"

# A diff can be run from the menu. This (and all commands) will be run from the base directory.
# If auto_diff is true, then a diff will be automatically run after each set of changes
# is successfully applied to the code base.
auto_diff = false  # [true|false]
diff_command = "git diff"

# ------------------------------------------------------------------
# ICONS – you can override any of the five status symbols here
# Symbols can be unicode characters or the special "spinner" value
# to show an animated spinner in that location.
# ------------------------------------------------------------------
[icons]
not_configured = "⚠️"
not_run        = "❓"
waiting        = "⏳"
success        = "✅"
failed         = "❌"
running        = "spinner"

# ===================================================================
# COMMANDS: Define post-processing actions after LLM code changes
# ===================================================================
# These commands can run automatically on success/failure/revert,
# be triggered manually from the menu, and optionally include output
# in the next LLM prompt.
# Configuration:
# name = "name" the name that is associated with the command
# show_in_header = [true|false] # if true the command state will be shown in the menu header. Default is false.
# hot_key = '<key>'  # if set then the given hotkey will automatically run the command (be careful not to clobber here). Default is no hotkey.
# command = "command to run"  # the command to run. May include {{ base_directory }} template variable. Must be defined or results will show bad config icon (e.g. ⚠️).
# include_results = [true|false]  # if true then results will be included in the next prompt. Default is false.
# success = [exit_code|command]  # command to run to determine success of command run. If exit_code (default) is used, will use exit code to determine success (e.g. result from subprocess, which is equivalent of $? in Linux)
# run_on = <one or more of the following>:
# - changes_received  → after code changes received from LLM (e.g. in applydir.json)
# - changes_success   → after code changes application successful
# - changes_failed    → after code changes application failed
# - revert            → after git revert
# - startup           → when vibedir starts
# - no_manual         → do not create manual run option in menu for this command. Default is to create manual run option.
# - prompt_send       → before sending prompt to LLM (will be on prompt copy is clipboard mode)
# - prompt_receive    → after LLM response received (API mode only)

[[command]]  # Does it make sense to define this here or should we handle it specially in code?
name = "Code Changes"
run_on = ["changes_received"]
command = "apply_code_changes" # special command to apply code changes from applydir.json

[[command]]
name = "Format Code"
run_on = ["changes_success"]
command = "ruff format {{ base_directory }}"

[[command]]
name = "Lint"
show_in_header = true
run_on = ["changes_success"]
include_results = true
command = "ruff check {{ base_directory }}"
success = "exit_code"

[[command]]
name = "Tests"
hotkey = 't'
show_in_header = true
run_on = ["changes_success"]
include_results = true
command = "pytest {{ tests_directory }}"
success = "exit_code"

# Show legend in the header
show_command_legend_in_header = true  # [true|false]

# Default tests directory (used in Tests command above)
tests_directory = "{{ base_directory }}/tests"

# Choose a standard level for logging 
[logging]
level = "INFO"  # [CRITICAL|ERROR|WARNING|INFO|DEBUG]