import logging
from io import StringIO

import pytest
from dynaconf import Dynaconf
from unittest.mock import mock_open, patch

from vibedir.config import load_config
from vibedir.vibedir import build_prompt, call_llm_api, save_output, setup_logging, validate_llm_response


@pytest.fixture
def sample_config_content():
    return Dynaconf(
        settings_files=[],
        APPLY_CHANGES={"AUTO_APPLY": False},
        COMMANDS={"SHELL_TYPE": "bash"},
        LOGGING={"LEVEL": "INFO"},
        prompt_template="""
You are a code modification assistant. Below is the content of a prepped_dir.txt file generated by prepdir, listing files and additional commands for a project. Your task is to apply the following changes: {user_request}. Return the modified content in a file named modified_prepped_dir.txt, preserving the original format, including delimiters (e.g., =-=, ===---===), file markers (Begin File, End File), and additional commands section. Ensure filenames in Begin File and End File markers match exactly, and only include valid code changes.

=== prepped_dir.txt Content ===
{prepped_dir_content}
=== End prepped_dir.txt Content ===

Output the modified content as modified_prepped_dir.txt with the same structure.
""",
        llm={
            "provider": "grok",
            "endpoint": "https://api.x.ai/v1",
            "api_key": "test_key",
            "model": "grok-3",
        },
    )


@pytest.fixture
def capture_log(sample_config_content):
    """Capture logging output."""
    log_output = StringIO()
    handler = logging.StreamHandler(log_output)
    setup_logging(sample_config_content, handler)
    yield log_output
    logging.getLogger().handlers = []
    logging.getLogger().setLevel(logging.NOTSET)


def test_load_config(tmp_path, capture_log):
    """Test loading configuration from YAML file."""
    config_content = """
APPLY_CHANGES:
  AUTO_APPLY: false
COMMANDS:
  SHELL_TYPE: "bash"
LOGGING:
  LEVEL: "INFO"
prompt_template: |
  You are a code modification assistant. Below is the content of a prepped_dir.txt file generated by prepdir, listing files and additional commands for a project. Your task is to apply the following changes: {user_request}. Return the modified content in a file named modified_prepped_dir.txt, preserving the original format, including delimiters (e.g., =-=, ===---===), file markers (Begin File, End File), and additional commands section. Ensure filenames in Begin File and End File markers match exactly, and only include valid code changes.

  === prepped_dir.txt Content ===
  {prepped_dir_content}
  === End prepped_dir.txt Content ===

  Output the modified content as modified_prepped_dir.txt with the same structure.
llm:
  provider: grok
  endpoint: https://api.x.ai/v1
  api_key: test_key
  model: grok-3
"""
    config_path = tmp_path / "config.yaml"
    config_path.write_text(config_content)

    config = load_config("vibedir", str(config_path))

    assert config.APPLY_CHANGES.AUTO_APPLY is False
    assert config.COMMANDS.SHELL_TYPE == "bash"
    assert config.LOGGING.LEVEL == "INFO"
    assert "modified_prepped_dir.txt" in config.prompt_template
    assert config.llm.provider == "grok"


def test_load_config_invalid_shell(tmp_path, capture_log):
    """Test handling invalid shell_type in config."""
    config_content = """
APPLY_CHANGES:
  AUTO_APPLY: false
COMMANDS:
  SHELL_TYPE: "invalid"
LOGGING:
  LEVEL: "INFO"
"""
    config_path = tmp_path / "config.yaml"
    config_path.write_text(config_content)

    config = load_config("vibedir", str(config_path))

    assert config.COMMANDS.SHELL_TYPE == "bash"  # Defaults to bash
    log_output = capture_log.getvalue()
    assert "Invalid shell_type 'invalid' in config; defaulting to 'bash'" in log_output


def test_load_config_missing_file():
    """Test handling missing config file."""
    # Set up logging to capture warnings
    log_output = StringIO()
    handler = logging.StreamHandler(log_output)
    logger = logging.getLogger("vibedir.config")
    logger.setLevel(logging.WARNING)
    logger.handlers = [handler]

    with patch("importlib.resources.files") as mock_files:
        mock_files.side_effect = Exception("Mocked resource error")
        config = load_config("vibedir", "dummy_config.yaml")

    assert isinstance(config, Dynaconf)
    assert config.get("COMMANDS.SHELL_TYPE", "bash") == "bash"
    assert config.get("APPLY_CHANGES.AUTO_APPLY", False) is False
    assert config.get("LOGGING.LEVEL", "INFO") == "INFO"
    log_output_value = log_output.getvalue()
    assert "Failed to load bundled config for vibedir" in log_output_value

    # Clean up logging
    logger.handlers = []
    logging.getLogger().setLevel(logging.NOTSET)


def test_build_prompt(sample_config_content):
    """Test building a prompt from prepped_dir.txt and user request."""
    prepped_content = "=-= Begin File: 'test_file.py' =-=\nprint('Hello')\n=-= End File: 'test_file.py' =-="
    with patch("builtins.open", mock_open(read_data=prepped_content)):
        prompt = build_prompt("dummy_path.txt", "Add async", sample_config_content)

    assert "apply the following changes: Add async" in prompt
    assert prepped_content in prompt
    assert "modified_prepped_dir.txt" in prompt


def test_build_prompt_missing_file(capture_log, sample_config_content):
    """Test handling missing prepped_dir.txt."""
    with patch("builtins.open", side_effect=FileNotFoundError):
        with pytest.raises(FileNotFoundError):
            build_prompt("dummy_path.txt", "Add async", sample_config_content)

    log_output = capture_log.getvalue()
    assert "Failed to read dummy_path.txt" in log_output


def test_save_output(tmp_path, capture_log):
    """Test saving output to a file."""
    output_path = tmp_path / "modified_prepped_dir.txt"
    content = "Test content"
    save_output(content, str(output_path))

    assert output_path.read_text() == "Test content"
    log_output = capture_log.getvalue()
    assert f"Saved output to {output_path}" in log_output


def test_save_output_failure(tmp_path, capture_log):
    """Test handling save output failure."""
    output_path = tmp_path / "nonexistent/dir/output.txt"
    with pytest.raises(OSError):
        save_output("Test content", str(output_path))

    log_output = capture_log.getvalue()
    assert f"Failed to save output to {output_path}" in log_output


def test_validate_llm_response():
    """Test validating a valid LLM response."""
    valid_content = "=-= Begin File: 'test.py' =-=\nprint('Hello')\n=-= End File: 'test.py' =-="
    validate_llm_response(valid_content)  # Should not raise


def test_validate_llm_response_invalid():
    """Test validating an invalid LLM response."""
    invalid_content = "Invalid content"
    with pytest.raises(ValueError, match="Invalid LLM response: missing required file markers"):
        validate_llm_response(invalid_content)


def test_call_llm_api(sample_config_content):
    """Test calling LLM API with a mocked OpenAI client."""
    mock_response = type("MockResponse", (), {
        "choices": [type("MockChoice", (), {
            "message": type("MockMessage", (), {
                "content": "=-= Begin File: 'test.py' =-=\nprint('Mock content')\n=-= End File: 'test.py' =-="
            })
        })]
    })()
    with patch("vibedir.vibedir.OpenAI") as mock_openai:
        mock_openai.return_value.chat.completions.create.return_value = mock_response
        content = call_llm_api("Test prompt", sample_config_content)

    assert "=-= Begin File: 'test.py' =-=\nprint('Mock content')\n=-= End File: 'test.py' =-=" in content
    mock_openai.assert_called_once_with(base_url="https://api.x.ai/v1", api_key="test_key")


def test_call_llm_api_missing_api_key(sample_config_content):
    """Test calling LLM API with missing API key."""
    sample_config_content.llm.api_key = ""
    with pytest.raises(ValueError, match="LLM API key not provided in config"):
        call_llm_api("Test prompt", sample_config_content)